const { test, expect } = require("../fixtures");

/**
 * Helper: click the wallet button and wait for connection to complete.
 */
async function connectWallet(page) {
  const walletText = page.locator("#wallet-text");

  for (let attempt = 0; attempt < 3; attempt++) {
    await page.locator("#wallet-btn").click();
    try {
      await expect(walletText).not.toHaveText("Connect Freighter", {
        timeout: 5000,
      });
      return;
    } catch {
      await page.waitForTimeout(500);
    }
  }
  await expect(walletText).not.toHaveText("Connect Freighter", {
    timeout: 5000,
  });
}

test.describe("Deposit End-to-End Flow", () => {
  // Proof generation downloads large ZK artifacts (~13 MB) and runs
  // computationally expensive proving — give it plenty of time.
  test.setTimeout(180_000);

  test("load page, connect wallet, deposit and generate proof — capture all logs", async ({
    page,
  }) => {
    const logs = [];

    // Capture every console message from the browser
    page.on("console", (msg) => {
      const type = msg.type();
      const text = msg.text();
      logs.push({ type, text, timestamp: Date.now() });
      console.log(`[browser:${type}] ${text}`);
    });

    // Capture uncaught page errors
    page.on("pageerror", (err) => {
      logs.push({
        type: "pageerror",
        text: err.message,
        timestamp: Date.now(),
      });
      console.log(`[browser:pageerror] ${err.message}`);
    });

    // --- Step 1: Load the page and wait for WASM / app initialisation ---
    await page.goto("/");
    await page.waitForLoadState("networkidle");

    // Poll until the app has fully initialised (tab handlers attached,
    // deposit button present and disabled until wallet connects).
    await page.waitForFunction(
      () => {
        const depositBtn = document.querySelector("#btn-deposit");
        return depositBtn && depositBtn.disabled;
      },
      { timeout: 30_000, polling: 500 },
    );

    console.log("[test] Page loaded and app initialised");

    // --- Step 2: Connect the wallet ---
    await connectWallet(page);

    const walletText = await page.locator("#wallet-text").textContent();
    expect(walletText).toContain("...");
    console.log(`[test] Wallet connected: ${walletText}`);

    // Deposit button should now be enabled
    const depositBtn = page.locator("#btn-deposit");
    await expect(depositBtn).toBeEnabled({ timeout: 5000 });

    // --- Step 3: Click deposit and wait for proof generation ---
    await depositBtn.click();
    console.log("[test] Deposit button clicked — waiting for proof generation");

    // Wait for the loading indicator to appear (confirms the flow started)
    const loadingIndicator = page.locator("#btn-deposit .btn-loading");
    await expect(loadingIndicator).not.toHaveClass(/hidden/, {
      timeout: 10_000,
    });
    console.log("[test] Deposit flow started (loading indicator visible)");

    // Wait for proof generation to complete or fail. We poll the button
    // state: the loading indicator gets the `hidden` class back once the
    // flow finishes (success or error).
    await page.waitForFunction(
      () => {
        const loading = document.querySelector("#btn-deposit .btn-loading");
        if (!loading) return true;
        return loading.classList.contains("hidden");
      },
      { timeout: 120_000, polling: 1000 },
    );

    console.log("[test] Deposit flow completed");

    // Assert that proof was generated by checking the captured logs
    const proofLog = logs.find((entry) =>
      entry.text.includes("[Deposit] Proof generated"),
    );
    expect(proofLog).toBeTruthy();
    console.log(`[test] Proof generated: ${proofLog.text}`);

    // --- Step 4: Print captured logs ---
    console.log("\n--- Console Log Summary ---");
    console.log(`Total messages captured: ${logs.length}`);

    const logsByType = {};
    for (const entry of logs) {
      logsByType[entry.type] = (logsByType[entry.type] || 0) + 1;
      console.log(`  [${entry.type}] ${entry.text}`);
    }

    console.log("\nBreakdown by type:");
    for (const [type, count] of Object.entries(logsByType)) {
      console.log(`  ${type}: ${count}`);
    }
    console.log("--- End Summary ---\n");

    // We should have captured meaningful log output from the deposit flow
    expect(logs.length).toBeGreaterThan(0);
  });
});
